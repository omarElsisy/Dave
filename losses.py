import numpy as np


def ccc(y_true, y_pred):
    '''Lin's Concordance correlation coefficient: https://en.wikipedia.org/wiki/Concordance_correlation_coefficient

    The concordance correlation coefficient is the correlation between two variables that fall on the 45 degree line through the origin.

    It is a product of
    - precision (Pearson correlation coefficient) and
    - accuracy (closeness to 45 degree line)
    Interpretation:
    - `rho_c =  1` : perfect agreement
    - `rho_c =  0` : no agreement
    - `rho_c = -1` : perfect disagreement 

    Args: 
    - y_true: ground truth
    - y_pred: predicted values

    Returns:
    - concordance correlation coefficient (float)
    '''

    import keras.backend as K
    # means
    x_m = K.mean(y_true, axis=0)
    y_m = K.mean(y_pred, axis=0)

    # variances
    x_var = K.var(y_true, axis=0)
    y_var = K.var(y_pred, axis=0)

    v_true = y_true - x_m
    v_pred = y_pred - y_m

    cor = K.sum(v_pred * v_true) / (K.sqrt(K.sum(v_pred ** 2))
                                    * K.sqrt(K.sum(v_true ** 2)) + K.epsilon())

    x_std = K.std(y_true)
    y_std = K.std(y_pred)

    numerator = 2 * cor * x_std * y_std
    denominator = x_var + y_var+(x_m-y_m)**2

    ccc = numerator/denominator

    return ccc


def ccc1(y_true, y_pred):
    '''Lin's Concordance correlation coefficient: https://en.wikipedia.org/wiki/Concordance_correlation_coefficient

    The concordance correlation coefficient is the correlation between two variables that fall on the 45 degree line through the origin.

    It is a product of
    - precision (Pearson correlation coefficient) and
    - accuracy (closeness to 45 degree line)
    Interpretation:
    - `rho_c =  1` : perfect agreement
    - `rho_c =  0` : no agreement
    - `rho_c = -1` : perfect disagreement 

    Args: 
    - y_true: ground truth
    - y_pred: predicted values

    Returns:
    - concordance correlation coefficient (float)
    '''

    import keras.backend as K
    # covariance between y_true and y_pred
    N = K.int_shape(y_pred)[-1]
    # s_xy = 1.0 / (N - 1.0 + K.epsilon()) * K.sum((y_true - K.mean(y_true)) * (y_pred - K.mean(y_pred)))
    s_xy = K.mean(K.sum((y_true - K.mean(y_true)) * (y_pred - K.mean(y_pred))))
    # means
    x_m = K.mean(y_true)
    y_m = K.mean(y_pred)
    # variances
    s_x_sq = K.var(y_true)
    s_y_sq = K.var(y_pred)

    # condordance correlation coefficient
    ccc = (2.0*s_xy) / (s_x_sq + s_y_sq + (x_m-y_m)**2)

    return ccc


def loss_ccc(y_true, y_pred):
    return 1 - ccc(y_true, y_pred)
# loss_ccc


def ccc_numpy(y_true, y_pred):
    '''Reference numpy implementation of Lin's Concordance correlation coefficient'''

    # covariance between y_true and y_pred
    s_xy = np.cov([y_true, y_pred])[0, 1]
    # means
    x_m = np.mean(y_true)
    y_m = np.mean(y_pred)
    # variances
    s_x_sq = np.var(y_true)
    s_y_sq = np.var(y_pred)

    # condordance correlation coefficient
    ccc = (2.0*s_xy) / (s_x_sq + s_y_sq + (x_m-y_m)**2)

    return ccc
